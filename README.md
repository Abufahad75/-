--insert-globals, --ig, --fast [default: false] Skip detection and always insert definitions for process, global, __filename, and __dirname. benefit: faster builds cost: extra bytes --insert-global-vars, --igv Comma-separated list of global variables to detect and define. Default: __filename,__dirname,process,Buffer,global --detect-globals, --dg [default: true] Detect the presence of process, global, __filename, and __dirname and define these values when present. benefit: npm modules more likely to work cost: slower builds --ignore-missing, --im [default: false] Ignore `require()` statements that don't resolve to anything. --noparse=FILE Don't parse FILE at all. This will make bundling much, much faster for giant libs like jquery or threejs. --no-builtins Turn off builtins. This is handy when you want to run a bundle in node which provides the core builtins. --no-commondir Turn off setting a commondir. This is useful if you want to preserve the original paths that a bundle was generated with. --no-bundle-external Turn off bundling of all external modules. This is useful if you only want to bundle your local files. --bare Alias for both --no-builtins, --no-commondir, and sets --insert-global-vars to just "__filename,__dirname". This is handy if you want to run bundles in node. --no-browser-field, --no-bf Turn off package.json browser field resolution. This is also handy if you need to run a bundle in node. --transform-key Instead of the default package.json#browserify#transform field to list all transforms to apply when running browserify, a custom field, like, e.g. package.json#browserify#production or package.json#browserify#staging can be used, by for example running: * `browserify index.js --transform-key=production > bundle.js` * `browserify index.js --transform-key=staging > bundle.js` --node Alias for --bare and --no-browser-field. --full-paths Turn off converting module ids into numerical indexes. This is useful for preserving the original paths that a bundle was generated with. --deps Instead of standard bundle output, print the dependency array generated by module-deps. --no-dedupe Turn off deduping. --list Print each file in the dependency graph. Useful for makefiles. --extension=EXTENSION Consider files with specified EXTENSION as modules, this option can used multiple times. --global-transform=MODULE, -g MODULE Use a transform module on all files after any ordinary transforms have run. --ignore-transform=MODULE, -it MODULE Do not run certain transformations, even if specified elsewhere. --plugin=MODULE, -p MODULE Register MODULE as a plugin. Passing arguments to transforms and plugins: For -t, -g, and -p, you may use subarg syntax to pass options to the transforms or plugin function as the second parameter. For example: -t [ foo -x 3 --beep ] will call the `foo` transform for each applicable file by calling: foo(file, { x: 3, beep: true }) 
Usage: browserify [entry files] {OPTIONS} Standard Options: --outfile, -o Write the browserify bundle to this file. If unspecified, browserify prints to stdout. --require, -r A module name or file to bundle.require() Optionally use a colon separator to set the target. --entry, -e An entry point of your app --ignore, -i Replace a file with an empty stub. Files can be globs. --exclude, -u Omit a file from the output bundle. Files can be globs. --external, -x Reference a file from another bundle. Files can be globs. --transform, -t Use a transform module on top-level files. --command, -c Use a transform command on top-level files. --standalone -s Generate a UMD bundle for the supplied export name. This bundle works with other module systems and sets the name given as a window global if no module system is found. --debug -d Enable source maps that allow you to debug your files separately. --help, -h Show this message For advanced options, type `browserify --help advanced`. Specify a parameter. 

Advanced Options: --insert-globals, --ig, --fast [default: false] Skip detection and always insert definitions for process, global, __filename, and __dirname. benefit: faster builds cost: extra bytes --insert-global-vars, --igv Comma-separated list of global variables to detect and define. Default: __filename,__dirname,process,Buffer,global --detect-globals, --dg [default: true] Detect the presence of process, global, __filename, and __dirname and define these values when present. benefit: npm modules more likely to work cost: slower builds --ignore-missing, --im [default: false] Ignore `require()` statements that don't resolve to anything. --noparse=FILE Don't parse FILE at all. This will make bundling much, much faster for giant libs like jquery or threejs. --no-builtins Turn off builtins. This is handy when you want to run a bundle in node which provides the core builtins. --no-commondir Turn off setting a commondir. This is useful if you want to preserve the original paths that a bundle was generated with. --no-bundle-external Turn off bundling of all external modules. This is useful if you only want to bundle your local files. --bare Alias for both --no-builtins, --no-commondir, and sets --insert-global-vars to just "__filename,__dirname". This is handy if you want to run bundles in node. --no-browser-field, --no-bf Turn off package.json browser field resolution. This is also handy if you need to run a bundle in node. --transform-key Instead of the default package.json#browserify#transform field to list all transforms to apply when running browserify, a custom field, like, e.g. package.json#browserify#production or package.json#browserify#staging can be used, by for example running: * `browserify index.js --transform-key=production > bundle.js` * `browserify index.js --transform-key=staging > bundle.js` --node Alias for --bare and --no-browser-field. --full-paths Turn off converting module ids into numerical indexes. This is useful for preserving the original paths that a bundle was generated with. --deps Instead of standard bundle output, print the dependency array generated by module-deps. --no-dedupe Turn off deduping. --list Print each file in the dependency graph. Useful for makefiles. --extension=EXTENSION Consider files with specified EXTENSION as modules, this option can used multiple times. --global-transform=MODULE, -g MODULE Use a transform module on all files after any ordinary transforms have run. --ignore-transform=MODULE, -it MODULE Do not run certain transformations, even if specified elsewhere. --plugin=MODULE, -p MODULE Register MODULE as a plugin. Passing arguments to transforms and plugins: For -t, -g, and -p, you may use subarg syntax to pass options to the transforms or plugin function as the second parameter. For example: -t [ foo -x 3 --beep ] will call the `foo` transform for each applicable file by calling: foo(file, { x: 3, beep: true }) 

التوافق

العديد من وحدات npm التي لا تعمل IO ستعمل فقط بعد تصفحها. يأخذ آخرون المزيد من العمل.

تم تغليف العديد من الوحدات المدمجة في العقدة للعمل في المتصفح ، ولكن فقط عندما require()تستخدم وظائفها أو تستخدمها بشكل صريح .

عندما تستخدم require()أيًا من هذه الوحدات ، ستحصل على رقاقة خاصة بالمتصفح:

يجزممتعادلوحدة التحكمالثوابتالتشفيرنطاقالأحداثhttphttpsنظام التشغيلpathPunycodeسلسلة الاستعلاممجرىسلسلة_فكودرتوقيتttyعنوان urlالاستفادةvmزليب

بالإضافة إلى ذلك ، إذا كنت تستخدم أيًا من هذه المتغيرات ، فسيتم تحديدها في الإخراج المجمّع بطريقة مناسبة للمتصفح:

معالجةمتعادلعام - كائن نطاق المستوى الأعلى (نافذة)__filename - مسار الملف للملف الجاري تنفيذه حاليًا__dirname - مسار الدليل للملف الجاري تنفيذه حاليًامزيد من الأمثلةيتطلب الخارجي

يمكنك بسهولة إنشاء حزمة من شأنها تصدير require()وظيفة حتى تتمكن require()من الوحدات النمطية من علامة برنامج نصي آخر. هنا سنقوم بإنشاء bundle.jsمع من خلال و الوجهين وحدات.

$ browserify -r through -r duplexer -r ./my-file.js:my-module > bundle.js 

ثم في صفحتك يمكنك القيام بما يلي:

<script src="bundle.js"></script> <script> var through = require('through'); var duplexer = require('duplexer'); var myModule = require('my-module'); /* ... */ </script>

external source maps

If you prefer the source maps be saved to a separate .js.map source map file, you may use exorcist in order to achieve that. It's as simple as:

$ browserify main.js --debug | exorcist bundle.js.map > bundle.js 

Learn about additional options here.

multiple bundles

If browserify finds a required function already defined in the page scope, it will fall back to that function if it didn't find any matches in its own set of bundled modules.

In this way, you can use browserify to split up bundles among multiple pages to get the benefit of caching for shared, infrequently-changing modules, while still being able to use require(). Just use a combination of --external and --require to factor out common dependencies.

For example, if a website with 2 pages, beep.js:

var robot = require('./robot.js'); console.log(robot('beep'));

and boop.js:

var robot = require('./robot.js'); console.log(robot('boop'));

both depend on robot.js:

module.exports = function (s) { return s.toUpperCase() + '!' };

$ browserify -r ./robot.js > static/common.js $ browserify -x ./robot.js beep.js > static/beep.js $ browserify -x ./robot.js boop.js > static/boop.js 

Then on the beep page you can have:

<script src="common.js"></script> <script src="beep.js"></script>

while the boop page can have:

<script src="common.js"></script> <script src="boop.js"></script>

This approach using -r and -x works fine for a small number of split assets, but there are plugins for automatically factoring out components which are described in the partitioning section of the browserify handbook.

api example

You can use the API directly too:

var browserify = require('browserify'); var b = browserify(); b.add('./browser/main.js'); b.bundle().pipe(process.stdout);

methods

var browserify = require('browserify')

browserify([files] [, opts])

Returns a new browserify instance.

filesfiles and opts are both optional, but must be in the order shown if both are passed.

Entry files may be passed in files and / or opts.entries.

External requires may be specified in opts.require, accepting the same formats that the files argument does.

If an entry file is a stream, its contents will be used. You should pass opts.basedir when using streaming files so that relative requires can be resolved.

opts.entries has the same definition as files.

opts.noParse is an array which will skip all require() and global parsing for each file in the array. Use this for giant libs like jquery or threejs that don't have any requires or node-style globals but take forever to parse.

opts.transform is an array of transform functions or modules names which will transform the source code before the parsing.

opts.ignoreTransform is an array of transformations that will not be run, even if specified elsewhere.

opts.plugin is an array of plugin functions or module names to use. See the plugins section below for details.

opts.extensions is an array of optional extra extensions for the module lookup machinery to use when the extension has not been specified. By default browserify considers only .js and .json files in such cases.

opts.basedir is the directory that browserify starts bundling from for filenames that start with ..

opts.paths is an array of directories that browserify searches when looking for modules which are not referenced using relative path. Can be absolute or relative to basedir. Equivalent of setting NODE_PATH environmental variable when calling browserify command.

opts.commondir sets the algorithm used to parse out the common paths. Use false to turn this off, otherwise it uses the commondir module.

opts.fullPaths disables converting module ids into numerical indexes. This is useful for preserving the original paths that a bundle was generated with.

opts.builtins sets the list of built-ins to use, which by default is set in lib/builtins.js in this distribution.

opts.bundleExternal boolean option to set if external modules should be bundled. Defaults to true.

When opts.browserField is false, the package.json browser field will be ignored. When opts.browserField is set to a string, then a custom field name can be used instead of the default "browser" field.

When opts.insertGlobals is true, always insert process, global, __filename, and __dirname without analyzing the AST for faster builds but larger output bundles. Default false.

When opts.detectGlobals is true, scan all files for process, global, __filename, and __dirname, defining as necessary. With this option npm modules are more likely to work but bundling takes longer. Default true.

When opts.ignoreMissing is true, ignore require() statements that don't resolve to anything.

When opts.debug is true, add a source map inline to the end of the bundle. This makes debugging easier because you can see all the original files if you are in a modern enough browser.

When opts.standalone is a non-empty string, a standalone module is created with that name and a umd wrapper. You can use namespaces in the standalone global export using a . in the string name as a separator, for example 'A.B.C'. The global export will be sanitized and camel cased.

Note that in standalone mode the require() calls from the original source will still be around, which may trip up AMD loaders scanning for require() calls. You can remove these calls with derequire:

$ npm install derequire $ browserify main.js --standalone Foo | derequire > bundle.js 

opts.insertGlobalVars will be passed to insert-module-globals as the opts.vars parameter.

opts.externalRequireName defaults to 'require' in expose mode but you can use another name.

opts.bare creates a bundle that does not include Node builtins, and does not replace global Node variables except for __dirname and __filename.

opts.node creates a bundle that runs in Node and does not use the browser versions of dependencies. Same as passing { bare: true, browserField: false }.

Note that if files do not contain javascript source code then you also need to specify a corresponding transform for them.

All other options are forwarded along to module-deps and browser-pack directly.

b.add(file, opts)

Add an entry file from file that will be executed when the bundle loads.

If file is an array, each item in file will be added as an entry file.

b.require(file, opts)

Make file available from outside the bundle with require(file).

The file param is anything that can be resolved by require.resolve(), including files from node_modules. Like with require.resolve(), you must prefix file with ./ to require a local file (not in node_modules).

file can also be a stream, but you should also use opts.basedir so that relative requires will be resolvable.

If file is an array, each item in file will be required. In file array form, you can use a string or object for each item. Object items should have a file property and the rest of the parameters will be used for the opts.

Use the expose property of opts to specify a custom dependency name. require('./vendor/angular/angular.js', {expose: 'angular'}) enables require('angular')

b.bundle(cb)

Bundle the files and their dependencies into a single javascript file.

Return a readable stream with the javascript file contents or optionally specify a cb(err, buf) to get the buffered results.

b.external(file)

Prevent file from being loaded into the current bundle, instead referencing from another bundle.

If file is an array, each item in file will be externalized.

If file is another bundle, that bundle's contents will be read and excluded from the current bundle as the bundle in file gets bundled.

b.ignore(file)

Prevent the module name or file at file from showing up in the output bundle.

If file is an array, each item in file will be ignored.

Instead you will get a file with module.exports = {}.

b.exclude(file)

Prevent the module name or file at file from showing up in the output bundle.

If file is an array, each item in file will be excluded.

If your code tries to require() that file it will throw unless you've provided another mechanism for loading it.

b.transform(tr, opts={})

Transform source code before parsing it for require() calls with the transform function or module name tr.

If tr is a function, it will be called with tr(file) and it should return a through-stream that takes the raw file contents and produces the transformed source.

If tr is a string, it should be a module name or file path of a transform module with a signature of:

var through = require('through'); module.exports = function (file) { return through() };

You don't need to necessarily use the through module. Browserify is compatible with the newer, more verbose Transform streams built into Node v0.10.

Here's how you might compile coffee script on the fly using .transform():

var coffee = require('coffee-script'); var through = require('through'); b.transform(function (file) { var data = ''; return through(write, end); function write (buf) { data += buf } function end () { this.queue(coffee.compile(data)); this.queue(null); } });

Note that on the command-line with the -c flag you can just do:

$ browserify -c 'coffee -sc' main.coffee > bundle.js 

Or better still, use the coffeeify module:

$ npm install coffeeify $ browserify -t coffeeify main.coffee > bundle.js 

If opts.global is true, the transform will operate on ALL files, despite whether they exist up a level in a 

var foo = require('./foo.js');
var bar = require('../lib/bar.js');
var gamma = require('gamma');

var elem = document.getElementById('result');
var x = foo(100) + bar('baz');
elem.textContent = gamma(x);
module.exports = function (n) { return n * 111 }
var foo = require('./foo.js');
var bar = require('../lib/bar.js');
var gamma = require('gamma');

var elem = document.getElementById('result');
var x = foo(100) + bar('baz');
elem.textContent = gamma(x);
